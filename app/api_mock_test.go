// Copyright 2023 Northern.tech AS
//
//	Licensed under the Apache License, Version 2.0 (the "License");
//	you may not use this file except in compliance with the License.
//	You may obtain a copy of the License at
//
//	    http://www.apache.org/licenses/LICENSE-2.0
//
//	Unless required by applicable law or agreed to in writing, software
//	distributed under the License is distributed on an "AS IS" BASIS,
//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//	See the License for the specific language governing permissions and
//	limitations under the License.

package app

import (
	context "context"
	"io"
	"sync"

	"github.com/mendersoftware/go-lib-micro/ws"
	api "github.com/northerntechhq/nt-connect/api"

	mock "github.com/stretchr/testify/mock"
)

type SocketMock struct {
	SendChan chan ws.ProtoMsg
	RecvChan chan ws.ProtoMsg
	ErrChan  chan error
	closed   chan struct{}
	mu       sync.Mutex
}

func (s *SocketMock) Output() <-chan ws.ProtoMsg {
	return s.SendChan
}
func (s *SocketMock) Input() chan<- ws.ProtoMsg {
	return s.RecvChan
}

func (s *SocketMock) Send(msg ws.ProtoMsg) error {
	select {
	case s.SendChan <- msg:
	case <-s.closed:
		return io.ErrClosedPipe
	}
	return nil
}

func (s *SocketMock) ReceiveChan() <-chan ws.ProtoMsg {
	return s.RecvChan
}

func (s *SocketMock) ErrorChan() <-chan error {
	return s.ErrChan
}

func (s *SocketMock) Close() error {
	s.mu.Lock()
	defer s.mu.Unlock()
	select {
	case <-s.closed:

	default:
		close(s.closed)
	}
	return nil
}

// Code generated by mockery v2.15.0. DO NOT EDIT.

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

// Authenticate provides a mock function with given fields: ctx
func (_m *Client) Authenticate(ctx context.Context) (*api.Authz, error) {
	ret := _m.Called(ctx)

	var r0 *api.Authz
	if rf, ok := ret.Get(0).(func(context.Context) *api.Authz); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Authz)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenSocket provides a mock function with given fields: ctx, authz
func (_m *Client) OpenSocket(ctx context.Context, authz *api.Authz) (api.Socket, error) {
	ret := _m.Called(ctx, authz)

	var r0 api.Socket
	if rf, ok := ret.Get(0).(func(context.Context, *api.Authz) api.Socket); ok {
		r0 = rf(ctx, authz)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(api.Socket)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *api.Authz) error); ok {
		r1 = rf(ctx, authz)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewClient(t mockConstructorTestingTNewClient) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
